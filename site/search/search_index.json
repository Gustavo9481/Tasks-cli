{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inicio","text":"<p>Tasks-cli es una aplicaci\u00f3n de lista de tareas con interfaz en la terminal, dise\u00f1ada para ser simple y eficiente.</p> <p>Este proyecto, aunque sencillo en su funcionalidad, sirve como un mostrario de buenas pr\u00e1cticas de desarrollo en Python, incluyendo:</p> <ul> <li>Arquitectura Limpia: Separaci\u00f3n clara de responsabilidades en modelos, repositorios, servicios y controladores.</li> <li>Tipado Estricto: Uso de <code>mypy</code> y <code>pydantic</code> para un c\u00f3digo robusto y sin errores de tipo.</li> <li>Pruebas Rigurosas: Implementaci\u00f3n de tests unitarios con <code>pytest</code> para garantizar la fiabilidad.</li> <li>Interfaz de Usuario Moderna: Construcci\u00f3n de una UI interactiva en la terminal con <code>Textual</code>.</li> </ul> <p>Navega por las diferentes secciones para aprender a usar la aplicaci\u00f3n, entender su arquitectura o contribuir a su desarrollo.</p>"},{"location":"arquitectura/","title":"Arquitectura del Proyecto","text":"<p>La arquitectura de Tasks-cli est\u00e1 dise\u00f1ada siguiendo los principios de Separaci\u00f3n de Responsabilidades (SoC), lo que busca desarrollar un  sistema robusto, mantenible y f\u00e1cil de testear.</p> <p>Se implementa un patr\u00f3n de arquitectura por capas, donde cada capa tiene un rol bien definido y se comunica con las dem\u00e1s a trav\u00e9s de interfaces claras.</p>"},{"location":"arquitectura/#diagrama-de-arquitectura","title":"Diagrama de Arquitectura","text":"<p>El siguiente diagrama muestra las capas principales de la aplicaci\u00f3n y el flujo de dependencias. La comunicaci\u00f3n es unidireccional (de arriba hacia abajo), asegurando que las capas superiores no conozcan los detalles de implementaci\u00f3n de las inferiores.</p> <p> </p>"},{"location":"arquitectura/#descripcion-de-las-capas","title":"Descripci\u00f3n de las Capas","text":""},{"location":"arquitectura/#1-capa-de-controladores-controllers","title":"1. Capa de Controladores (<code>controllers/</code>)","text":"<ul> <li>Responsabilidad: Gestionar toda la interacci\u00f3n con el usuario. Es la \u00fanica capa que \"sabe\" que estamos en una terminal.</li> <li>Componentes Clave:<ul> <li><code>interface.py</code>: Contiene la clase principal <code>Interface</code> (la app de Textual), que genera y gestiona la UI, los atajos de teclado y las acciones.</li> <li><code>screens.py</code>: Define las pantallas modales (<code>AskIdScreen</code>, <code>AddTaskScreen</code>, etc.) que se usan para capturar datos del usuario de forma aislada.</li> </ul> </li> <li>Flujo: Recibe las acciones del usuario, las traduce en llamadas a la capa de Servicios y, cuando recibe datos de vuelta, los formatea para mostrarlos en la terminal. Nunca interact\u00faa directamentecon el Repositorio.</li> </ul>"},{"location":"arquitectura/#2-capa-de-servicios-services","title":"2. Capa de Servicios (<code>services/</code>)","text":"<ul> <li>Responsabilidad: Contener la l\u00f3gica de negocio de la aplicaci\u00f3n.</li> <li>Componentes Clave:<ul> <li><code>task_service.py</code>: La clase <code>TaskService</code> implementa las operaciones como \"crear una nueva tarea\" o \"filtrar tareas\".</li> </ul> </li> <li>Flujo: Es llamado por la capa de Controladores. Administra las operaciones validando datos, creando objetos del Modelo y utilizando la capa de Repositorios para persistir o recuperar informaci\u00f3n. No sabe nada sobre la interfaz de usuario ni sobre consultas SQL.</li> </ul>"},{"location":"arquitectura/#3-capa-de-repositorios-repositories","title":"3. Capa de Repositorios (<code>repositories/</code>)","text":"<ul> <li>Responsabilidad: Abstraer y gestionar todo el acceso a la base de datos. Es la \u00fanica capa que sabe c\u00f3mo y d\u00f3nde se guardan los datos.</li> <li>Componentes Clave:<ul> <li><code>repository_db.py</code>: La clase <code>RepositoryDB</code> implementa los m\u00e9todos para cada operaci\u00f3n en la base de datos (CRUD: Create, Read, Update, Delete).</li> <li><code>querys.py</code>: Centraliza todas las sentencias SQL como constantes, mejorando la legibilidad y el mantenimiento.</li> <li><code>connection_manager.py</code>: Proporciona un decorador (<code>@connection_manager</code>) que gestiona autom\u00e1ticamente el ciclo de vida de la conexi\u00f3n a la base de datos, manteniendo los m\u00e9todos limpios y enfocados en su tarea.</li> </ul> </li> <li>Flujo: Es utilizado exclusivamente por la capa de Servicios. Recibe \u00f3rdenes, ejecuta las consultas SQL correspondientes y devuelve los datos crudos o los transforma en objetos del Modelo.</li> </ul>"},{"location":"arquitectura/#4-capa-de-modelos-models","title":"4. Capa de Modelos (<code>models/</code>)","text":"<ul> <li>Responsabilidad: Definir la estructura de los datos de la aplicaci\u00f3n. Act\u00faa como un Data Transfer Object (DTO).</li> <li>Componentes Clave:<ul> <li><code>model_task.py</code>: Define la clase <code>Task</code> usando <code>Pydantic</code> para la validaci\u00f3n autom\u00e1tica de tipos y restricciones.</li> </ul> </li> <li>Flujo: Los objetos <code>Task</code> son utilizados por todas las capas para asegurar un transporte de datos consistente y seguro a trav\u00e9s de la aplicaci\u00f3n.</li> </ul>"},{"location":"arquitectura/#flujo-de-ejemplo-anadir-una-nueva-tarea","title":"Flujo de Ejemplo: A\u00f1adir una Nueva Tarea","text":"<ol> <li> <p>Usuario: Presiona la tecla <code>n</code> en la terminal.</p> </li> <li> <p>Controlador (<code>Interface</code>): El <code>action_add_task</code> es invocado. Muestra la pantalla <code>AddTaskScreen</code>.</p> </li> <li> <p>Controlador (<code>AddTaskScreen</code>): El usuario rellena los datos y presiona \"Crear\". La pantalla se cierra y devuelve un diccionario con los datos a <code>Interface</code>.</p> </li> <li> <p>Controlador (<code>Interface</code>): El m\u00e9todo <code>notification_add_task</code> recibe los datos y llama a <code>TaskService.new_task_service()</code>.</p> </li> <li> <p>Servicio (<code>TaskService</code>): Recibe los datos, crea un objeto <code>Task</code> validado por Pydantic.</p> </li> <li> <p>Servicio (<code>TaskService</code>): Llama a <code>RepositoryDB.new_task()</code>, pas\u00e1ndole el objeto <code>Task</code>.</p> </li> <li> <p>Repositorio (<code>RepositoryDB</code>): El decorador <code>@connection_manager</code> abre una conexi\u00f3n. El m\u00e9todo <code>new_task</code> extrae los datos del objeto <code>Task</code>, ejecuta la <code>INSERT</code> query y hace commit.</p> </li> <li> <p>Retorno: El control vuelve a trav\u00e9s de las capas. La <code>Interface</code> finalmente llama a <code>_update_table()</code> para refrescar la UI con la nueva tarea.</p> </li> </ol>"},{"location":"guia_desarrollo/","title":"Gu\u00eda de Desarrollo","text":"<p>Esta gu\u00eda est\u00e1 destinada a desarrolladores que deseen contribuir al proyecto, o para configurar el entorno de desarrollo desde cero.</p>"},{"location":"guia_desarrollo/#1-requisitos-previos","title":"1. Requisitos Previos","text":"<ul> <li>Python 3.11 o superior.</li> <li><code>uv</code>: Un instalador y gestor de paquetes de Python extremadamente r\u00e1pido, escrito en Rust. Si no lo tienes, puedes instalarlo       siguiendo las instrucciones oficiales.</li> </ul>"},{"location":"guia_desarrollo/#2-configuracion-del-entorno","title":"2. Configuraci\u00f3n del Entorno","text":"<p>Sigue estos pasos para tener un entorno de desarrollo funcional:</p>"},{"location":"guia_desarrollo/#a-clonar-el-repositorio","title":"a. Clonar el Repositorio","text":"<pre><code>  git clone https://github.com/Gustavo9481/Tasks-cli.git\n  cd Tasks-cli\n</code></pre>"},{"location":"guia_desarrollo/#b-crear-el-entorno-virtual","title":"b. Crear el Entorno Virtual","text":"<p>Usamos <code>uv</code> para crear y gestionar el entorno virtual. Esto asegura que las dependencias del proyecto est\u00e9n aisladas.</p> <pre><code>  uv venv\n</code></pre> <p>Este comando crear\u00e1 una carpeta <code>.venv</code> en la ra\u00edz del proyecto y la activar\u00e1 autom\u00e1ticamente en tu sesi\u00f3n de terminal actual.</p>"},{"location":"guia_desarrollo/#c-instalar-dependencias","title":"c. Instalar Dependencias","text":"<p>Todas las dependencias necesarias para el desarrollo (incluyendo las de producci\u00f3n) se encuentran en el archivo <code>pyproject.toml</code>.</p> <pre><code>  uv pip install \".[dev]\"\n</code></pre>"},{"location":"guia_desarrollo/#3-herramientas-de-calidad-de-codigo","title":"3. Herramientas de Calidad de C\u00f3digo","text":"<p>Este proyecto utiliza un conjunto de herramientas para mantener un c\u00f3digo limpio, consistente y libre de errores comunes. Es recomendable ejecutarlas antes de hacer un <code>commit</code>.</p>"},{"location":"guia_desarrollo/#a-formateo-de-codigo-y-linter","title":"a. Formateo de C\u00f3digo y Linter.","text":"<p><code>ruff</code> es un formateador de c\u00f3digo \"testarudo\" que asegura un estilo consistente en todo el proyecto.</p> <pre><code>  uv run ruff check .\n</code></pre>"},{"location":"guia_desarrollo/#b-verificacion-de-tipos-mypy","title":"b. Verificaci\u00f3n de Tipos (Mypy)","text":"<p><code>mypy</code> es un verificador de tipos est\u00e1tico. Revisa las anotaciones de tipo para prevenir errores comunes antes de que el c\u00f3digo se ejecute.</p> <pre><code>  uv run mypy .\n</code></pre>"},{"location":"guia_desarrollo/#4-ejecucion-de-pruebas-pytest","title":"4. Ejecuci\u00f3n de Pruebas (Pytest)","text":"<p>Las pruebas son una parte fundamental del proyecto y se utilizan para verificar que la l\u00f3gica de negocio y el acceso a datos funcionan como se espera.</p> <p>Para ejecutar todo el conjunto de pruebas:</p> <pre><code>  uv run pytest\n</code></pre>"},{"location":"guia_desarrollo/#5-ejecucion-de-la-aplicacion-en-modo-desarrollo","title":"5. Ejecuci\u00f3n de la Aplicaci\u00f3n en Modo Desarrollo","text":"<p>Para correr la aplicaci\u00f3n principal:   python main.py (Nota: Aseg\u00farate de que el archivo principal se llame <code>main.py</code> o ajusta el comando seg\u00fan corresponda).</p>"},{"location":"guia_usuario/","title":"Gu\u00eda de Usuario","text":"<p>\u00a1Bienvenido a Tasks-cli ! Esta gu\u00eda te mostrar\u00e1 c\u00f3mo instalar y utilizar la aplicaci\u00f3n para gestionar tus tareas directamente desde la terminal.</p>"},{"location":"guia_usuario/#1-instalacion","title":"1. Instalaci\u00f3n","text":"<p>Para utilizar la aplicaci\u00f3n, necesitas tener Python 3.11 o una versi\u00f3n superior instalada en tu sistema.</p> <p>Sigue estos sencillos pasos:</p>"},{"location":"guia_usuario/#a-descarga-del-proyecto","title":"a. Descarga del Proyecto","text":"<p>Primero, descarga el c\u00f3digo fuente. Puedes hacerlo clonando el repositorio con <code>git</code>:</p> <pre><code>  git clone https://github.com/Gustavo9481/Tasks-cli.git\n  cd Tasks-cli\n</code></pre> <p>O descargando el archivo ZIP directamente desde GitHub.</p>"},{"location":"guia_usuario/#b-instalacion-de-dependencias","title":"b. Instalaci\u00f3n de Dependencias","text":"<p>La aplicaci\u00f3n utiliza algunas librer\u00edas de Python que deben ser instaladas.  La forma m\u00e1s sencilla es usando <code>uv</code> (o <code>pip</code>) y el archivo <code>pyproject.toml</code>.</p> <p>Crea el entorno virtual</p> <pre><code>  uv venv\n</code></pre> <p>Instalar las dependencias</p> <pre><code>  uv pip install \".[dev]\"\n</code></pre>"},{"location":"guia_usuario/#2-ejecucion-de-la-aplicacion","title":"2. Ejecuci\u00f3n de la Aplicaci\u00f3n","text":"<p>Una vez instaladas las dependencias, puedes iniciar la aplicaci\u00f3n ejecutando el siguiente comando desde la carpeta ra\u00edz del proyecto:</p> <pre><code>  tasks-cli\n</code></pre> <p>(Nota: El archivo principal debe llamarse <code>main.py</code> o el comando debe  ajustarse al nombre correcto).</p> <p>Al ejecutarlo, ver\u00e1s la interfaz principal con tu lista de tareas.</p>"},{"location":"guia_usuario/#3-funcionalidades-y-atajos-de-teclado","title":"3. Funcionalidades y Atajos de Teclado","text":"<p>La interfaz es completamente interactiva y se maneja con atajos de teclado.  La tabla de tareas se puede navegar con las flechas arriba y abajo.</p> <p>Aqu\u00ed tienes la lista de acciones disponibles:</p> Tecla Acci\u00f3n Descripci\u00f3n n Nueva Tarea Abre un formulario para crear una nueva tarea. e Editar Tarea Editar una tarea ingresando el ID. d Eliminar Tarea Eliminar uns tarea ingresando el ID. m Marcar/Desmarcar Cambiar el status de una tarea ingresando ID. v Ver Detalles Ver los detalles o anotaciones extras ingresando ID. f Filtrar Tareas Filtrar tareas por status, tag o prioridad. r Refrescar Tareas Actualizar la lista de tareas. q Salir Cierra laaplicaci\u00f3n. <p>\u00a1Y eso es todo! Con estos comandos puedes gestionar tus tareas de forma r\u00e1pida  y eficiente sin salir de tu terminal.</p>"},{"location":"referencia_api/controllers/interface/","title":"Controlador: Interface","text":""},{"location":"referencia_api/controllers/interface/#controllersinterface","title":"<code>controllers.interface</code>","text":"<p>Este m\u00f3dulo define la clase principal de la aplicaci\u00f3n Textual, que orquesta la UI y los eventos.</p>"},{"location":"referencia_api/controllers/interface/#clase-interface","title":"Clase <code>Interface</code>","text":"<p>               Bases: <code>App</code></p> <p>Clase principal de la interfaz Textual para la app 'Tasks-cli' de lista de tareas.</p> <p>Como clase principal, se encarga de: - Componer la layout inicial con widgets (Header, DataTable, Footer). - Definir los atajos de teclado globales (BINDINGS). - Lanzar acciones (<code>action_*</code>) que muestran pantallas modales para la   interacci\u00f3n con el usuario. - Recibir los resultados de las pantallas modales y ejecutar la l\u00f3gica   de negocio correspondiente a trav\u00e9s de <code>TaskService</code>.</p> Source code in <code>controllers/interface.py</code> <pre><code>class Interface(App):\n    \"\"\"Clase principal de la interfaz Textual para la app 'Tasks-cli' de lista\n    de tareas.\n\n    Como clase principal, se encarga de:\n    - Componer la layout inicial con widgets (Header, DataTable, Footer).\n    - Definir los atajos de teclado globales (BINDINGS).\n    - Lanzar acciones (`action_*`) que muestran pantallas modales para la\n      interacci\u00f3n con el usuario.\n    - Recibir los resultados de las pantallas modales y ejecutar la l\u00f3gica\n      de negocio correspondiente a trav\u00e9s de `TaskService`.\n    \"\"\"\n\n    BINDINGS = [\n        (\"q\", \"quit\", \"Salir\"),\n        (\"n\", \"add_task\", \"Nueva Tarea\"),\n        (\"e\", \"edit_task\", \"Editar Tarea\"),\n        (\"f\", \"filter_tasks\", \"Filtrar Tareas\"),\n        (\"d\", \"delete_task\", \"Eliminar Tarea\"),\n        (\"m\", \"check_or_uncheck_task\", \"Marcar/Desmarcar\"),\n        (\"r\", \"reset_filters\", \"Refrescar tareas\"),\n        (\"v\", \"view_details\", \"Ver Detalles\")\n    ]\n    CSS_PATH = \"../config/styles.css\"\n    TITLE = \"TASKS CLI - Lista de Tareas \uf058 \"\n\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compone el layout inicial de la aplicaci\u00f3n.\n\n        Este m\u00e9todo de Textual se llama una vez al iniciar la app para\n        renderizar los widgets est\u00e1ticos como el Header, Footer y DataTable.\n        \"\"\"\n        leyenda_texto_status = Text()\n        leyenda_texto_priority = Text()\n        leyenda_texto_notas = Text()\n        dinamic_status_colors(leyenda_texto_status)\n        dinamic_priority_colors(leyenda_texto_priority)\n        dinamic_notes_leyend(leyenda_texto_notas)\n        yield Header()\n        yield Static(leyenda_texto_status, id=\"leyenda\")\n        yield Static(leyenda_texto_priority, id=\"prioridad\")\n        yield Static(leyenda_texto_notas, id=\"notas\")\n        yield DataTable()\n        yield Footer()\n\n\n    def _update_table(self) -&gt; None:\n        \"\"\"Refresca el contenido del widget DataTable.\n\n        El m\u00e9todo se encarga de limpiar la tabla, obtener la lista\n        actualizada de tareas desde el `TaskService`, aplicar estilos din\u00e1micos\n        y volver a poblar las filas.\n        \"\"\"\n        table = self.query_one(DataTable)\n        service = TaskService()\n        table.clear()\n        tareas = service.get_tasks_for_ui()\n\n        for row_data in tareas[1:]:\n            styled_row = list(row_data)\n            status_texto = styled_row[1]\n            prioridad_texto = styled_row[4]\n            styled_status = get_status_style(status_texto)\n            if isinstance(styled_status, Text):\n                styled_status.justify = \"center\"\n            styled_priority = get_priority_style(prioridad_texto)\n            if isinstance(styled_priority, Text):\n                styled_priority.justify = \"center\"\n            notes_indicator = Text(\n                styled_row[5], \n                justify=\"center\", \n                style=UI_COLORS['green']\n            )\n            styled_row[1] = styled_status\n            styled_row[4] = styled_priority\n            styled_row[5] = notes_indicator\n            table.add_row(*styled_row)\n\n\n    def on_mount(self) -&gt; None:\n        \"\"\"Se ejecuta cuando la app se monta en el DOM.\n\n        Este m\u00e9todo de Textual se usa para realizar configuraciones iniciales,\n        como definir las cabeceras de la tabla y cargar los datos por primera vez.\n        \"\"\"\n        table = self.query_one(DataTable)\n        table.cursor_type = \"row\"\n        headers = (\"ID\", \"Status\", \"Tag\", \"Contenido\", \"Prioridad\", \"Notas\")\n\n        for label in headers:\n            if label == \"Contenido\":\n                table.add_column(label, width=90)\n            elif label == \"Tag\":\n                table.add_column(label, width=20)\n            elif label == \"Nota\":\n                table.add_column(label, width=10)\n            else:\n                table.add_column(label)\n        self._update_table()\n\n\n    # .. ................... Acciones y Notificaciones .................... ..\udb80\udf20\n    # Secci\u00f3n con la l\u00f3gica necesaria para las funciones de la app.\n\n    # .. ............................................................. add_task\n    def action_add_task(self) -&gt; None:\n        \"\"\"Maneja el atajo de teclado 'n' para a\u00f1adir una nueva tarea.\n\n        Esta acci\u00f3n abre la pantalla modal `AddTaskScreen` y le asigna el m\u00e9todo\n        `notification_add_task` como callback para procesar el resultado.\n        \"\"\"\n        self.push_screen(\n            AddTaskScreen(),\n            self.notification_add_task\n        )\n\n    def notification_add_task(self, new_task_data: dict | None) -&gt; None:\n        \"\"\"Callback que procesa los datos recibidos de `AddTaskScreen`.\n\n        Este m\u00e9todo es llamado por Textual cuando la pantalla `AddTaskScreen`\n        se cierra.\n        Valida los datos, utiliza `TaskService` para crear la tarea y actualiza\n        la tabla visual.\n\n        Args:\n            new_task_data (dict | None): Diccionario con los datos de la\n                tarea enviado desde el modal. Es `None` si el usuario cancel\u00f3\n                la operaci\u00f3n.\n        \"\"\"\n        if new_task_data:\n            if not new_task_data[\"content\"]:\n                self.app.notify(\n                    \"El contenido no puede estar vac\u00edo.\",\n                    title=\"Error\",\n                    severity=\"error\"\n                )\n                return\n            service = TaskService()\n            service.new_task_service(Task(**new_task_data))\n            self.app.notify(\n                f\"Tarea '{new_task_data['content']}' agregada.\",\n                title=\"Nueva Tarea\"\n            )\n            self._update_table()\n\n\n    # .. ................................................ check_or_uncheck_task\n    def action_check_or_uncheck_task(self) -&gt; None:\n        \"\"\"Maneja el atajo 'm' para marcar/desmarcar una tarea (cambiar status)\n\n        Abre la pantalla modal `AskIdScreen` para solicitar el ID de la tarea\n        y asigna `notification_check_or_uncheck_task` como callback.\n        \"\"\"\n        self.push_screen(\n            AskIdScreen(),\n            self.notification_check_or_uncheck_task\n        )\n\n    @require_valid_id\n    def notification_check_or_uncheck_task(self, task_id: int) -&gt; None:\n        \"\"\"Callback que cambia el estado de la tarea.\n\n        Es llamado por Textual al cerrar `AskIdScreen`. Utiliza `TaskService`\n        para cambiar el estado de la tarea y refresca la tabla.\n\n        Args:\n            task_id (int): ID de la tarea a modificar, validado por el\n                decorador `@require_valid_id`.\n        \"\"\"\n        service = TaskService()\n        service.check_or_uncheck_task_service(task_id)\n        self.app.notify(\n            f\"Tarea ID: {task_id} ha cambiado de estado.\",\n            title=\"Status Actualizado\"\n        )\n        self._update_table()\n\n\n    # .. .......................................................... delete_task\n    def action_delete_task(self) -&gt; None:\n        \"\"\"Maneja el atajo 'd' para eliminar una tarea.\n\n        Abre la pantalla modal `AskIdScreen` para solicitar el ID y asigna\n        `notification_delete_task` como callback.\n        \"\"\"\n        self.push_screen(AskIdScreen(), self.notification_delete_task)\n\n    @require_valid_id\n    def notification_delete_task(self, task_id: int) -&gt; None:\n        \"\"\"Callback que elimina la tarea especificada.\n\n        Es llamado por Textual al cerrar `AskIdScreen`. Emplea `TaskService`\n        para eliminar la tarea y actualiza la tabla.\n\n        Args:\n            task_id (int): ID de la tarea a eliminar, validado por el\n                 decorador `@require_valid_id`.\n        \"\"\"\n        service = TaskService()\n        service.delete_task_service(task_id)\n        self.app.notify(\n            f\"Tarea ID: {task_id} Eliminada.\", \n            title=\"Tarea Eliminada\", \n            severity=\"warning\"\n        )\n        self._update_table()\n\n\n    # .. ......................................................... filter_tasks\n    def action_filter_tasks(self) -&gt; None:\n        \"\"\"Maneja el atajo 'f' para filtrar tareas.\n\n        Abre la pantalla modal `FilterTasksScreen` y asigna\n        `notification_filter_tasks` como callback.\n        \"\"\"\n        self.push_screen(\n            FilterTasksScreen(), \n            self.notification_filter_tasks\n        )\n\n    def notification_filter_tasks(self, filter_data: dict | None) -&gt; None:\n        \"\"\"Callback que recibe los criterios de filtro y actualiza la tabla.\n\n        Limpia y estandariza los datos del filtro, llama al servicio para\n        obtener las tareas filtradas y actualiza el `DataTable` con los\n        resultados.\n\n        Args:\n            filter_data (dict | None): Diccionario con los filtros a aplicar.\n                Ej: `{'status': 'pending', 'priority': 'alta'}`.\n                Es `None` si el usuario cancel\u00f3 la pantalla de filtros.\n        \"\"\"\n        if filter_data:\n            # 1. formato para el diccionario: si un valor est\u00e1 vac\u00edo se\n            # convierte a None para que el servicio no lo use como filtro.\n            filters = {\n                key: value if value else None\n                for key, value in filter_data.items()\n            }\n\n            # 2. Llamada al servicio con los filtros desempaquetados.\n            service = TaskService()\n            filtered_tasks_objects = service.filter_tasks_service(**filters)\n\n            # 3. Formateo de los resultados para la tabla\n            # (incluyendo cabeceras).\n            headers = (\"ID\", \"Status\", \"Tag\", \"Contenido\", \"Prioridad\")\n            results_for_ui: list[Any] = [headers]\n            for task in filtered_tasks_objects:\n                results_for_ui.append(\n                    (task.id,\n                     task.status,\n                     task.tag,\n                     task.content,\n                     task.priority\n                     )\n                )\n\n            # 4. Actualizaci\u00f3n de la tabla con los datos filtrados.\n            table = self.query_one(DataTable)\n            # Limpia las filas anteriores.\n            table.clear()\n\n            # A\u00f1adimos solo las filas filtradas\n            for row_data in results_for_ui[1:]:\n                styled_row = list(row_data)\n                status_texto = styled_row[1]\n                prioridad_texto = styled_row[4]\n                styled_status = get_status_style(status_texto)\n                if isinstance(styled_status, Text):\n                    styled_status.justify = \"center\"\n                styled_priority = get_priority_style(prioridad_texto)\n                if isinstance(styled_priority, Text):\n                    styled_priority.justify = \"center\"\n                styled_row[1] = styled_status\n                styled_row[4] = styled_priority\n                table.add_row(*styled_row)\n\n            self.app.notify(\n                f\"Mostrando {len(filtered_tasks_objects)} tareas filtradas.\"\n            )\n\n\n    # .. ............................................................ edit_task\n    def action_edit_task(self) -&gt; None:\n        \"\"\"Maneja el atajo 'e' para iniciar la edici\u00f3n de una tarea.\n\n        Abre `AskIdScreen` para obtener el ID de la tarea a editar y asigna\n        `_start_edit_process` como callback.\n        \"\"\"\n        self.push_screen(\n            AskIdScreen(),\n            self._start_edit_process\n        )\n\n    @require_valid_id\n    def _start_edit_process(self, task_id: int) -&gt; None:\n        \"\"\"Callback que obtiene la tarea y muestra la pantalla de edici\u00f3n.\n\n        Es llamado al cerrar `AskIdScreen`. Obtiene el objeto de la tarea\n        y abre la pantalla `AskTaskEdit`, pas\u00e1ndole la tarea y asignando\n        `_save_edit_changes` como el siguiente callback.\n\n        Args:\n            task_id (int): ID de la tarea a editar, validado por\n                `@require_valid_id`.\n        \"\"\"\n        service = TaskService()\n        task_to_edit = service.get_task_by_id_service(task_id)\n        if task_to_edit:\n            self.push_screen(\n                AskTaskEdit(task_to_edit),\n                self._save_edit_changes\n            )\n\n    def _save_edit_changes(self, updated_data: dict | None) -&gt; None:\n        \"\"\"Callback final que guarda los cambios de la edici\u00f3n.\n\n        Es llamado al cerrar `AskTaskEdit`. Si hay datos, extrae el ID,\n        llama al servicio para actualizar la tarea y refresca la tabla.\n\n        Args:\n            updated_data (dict | None): Diccionario con datos actualizados.\n                Contiene un campo 'id' y los dem\u00e1s campos modificados. Es `None`\n                si el usuario cancel\u00f3 la edici\u00f3n.\n        \"\"\"\n        if updated_data:\n            task_id = updated_data.pop(\"id\")\n            new_data = updated_data\n            service = TaskService()\n            service.update_task_service(task_id, new_data)\n            self.app.notify(\n                f\"Tarea ID: '{task_id}' ha sido actualizada.\",\n                title=\"Tarea Editada\"\n            )\n            self._update_table()\n\n\n    # .. ......................................................... view_details\n    def action_view_details(self) -&gt; None:\n        \"\"\"Maneja el atajo 'v' para ver los detalles de una tarea.\n\n        Abre `AskIdScreen` para obtener el ID y asigna `_show_details_screen`\n        como callback.\n        \"\"\"\n        self.push_screen(\n            AskIdScreen(),\n            self._show_details_screen\n        )\n\n\n    @require_valid_id\n    def _show_details_screen(self, task_id: int) -&gt; None:\n        \"\"\"Callback que obtiene la tarea y muestra la pantalla de detalles.\n\n        Es llamado al cerrar `AskIdScreen`. Obtiene la tarea completa y\n        muestra la pantalla `ViewDetailsScreen` con su contenido.\n\n        Args:\n            task_id (int): ID de la tarea a consultar, validado por\n                `@require_valid_id`.\n        \"\"\"\n        service = TaskService()\n        task = service.get_task_by_id_service(task_id)\n\n        # Comprobaci\u00f3n de que la tarea y sus atributos requeridos no son nulos.\n        if task and task.id is not None and task.details is not None:\n            # Mostrar la pantalla de detalles con la tarea extra\u00edda.\n            self.push_screen(\n                ViewDetailsScreen(\n                    details_content=task.details,\n                    task_id=task.id\n                )\n            )\n\n\n    # .. ........................................................ reset_filters\n    def action_reset_filters(self) -&gt; None:\n        \"\"\"Maneja el atajo 'r' para limpiar filtros y refrescar la tabla.\n\n        Llama directamente a `_update_table()` para recargar la lista\n        completa de tareas.\n        \"\"\"\n        self._update_table()\n        self.app.notify(\n            \"Filtros limpiados. Mostrando todas las tareas.\"\n        )\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.action_add_task","title":"<code>action_add_task()</code>","text":"<p>Maneja el atajo de teclado 'n' para a\u00f1adir una nueva tarea.</p> <p>Esta acci\u00f3n abre la pantalla modal <code>AddTaskScreen</code> y le asigna el m\u00e9todo <code>notification_add_task</code> como callback para procesar el resultado.</p> Source code in <code>controllers/interface.py</code> <pre><code>def action_add_task(self) -&gt; None:\n    \"\"\"Maneja el atajo de teclado 'n' para a\u00f1adir una nueva tarea.\n\n    Esta acci\u00f3n abre la pantalla modal `AddTaskScreen` y le asigna el m\u00e9todo\n    `notification_add_task` como callback para procesar el resultado.\n    \"\"\"\n    self.push_screen(\n        AddTaskScreen(),\n        self.notification_add_task\n    )\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.action_check_or_uncheck_task","title":"<code>action_check_or_uncheck_task()</code>","text":"<p>Maneja el atajo 'm' para marcar/desmarcar una tarea (cambiar status)</p> <p>Abre la pantalla modal <code>AskIdScreen</code> para solicitar el ID de la tarea y asigna <code>notification_check_or_uncheck_task</code> como callback.</p> Source code in <code>controllers/interface.py</code> <pre><code>def action_check_or_uncheck_task(self) -&gt; None:\n    \"\"\"Maneja el atajo 'm' para marcar/desmarcar una tarea (cambiar status)\n\n    Abre la pantalla modal `AskIdScreen` para solicitar el ID de la tarea\n    y asigna `notification_check_or_uncheck_task` como callback.\n    \"\"\"\n    self.push_screen(\n        AskIdScreen(),\n        self.notification_check_or_uncheck_task\n    )\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.action_delete_task","title":"<code>action_delete_task()</code>","text":"<p>Maneja el atajo 'd' para eliminar una tarea.</p> <p>Abre la pantalla modal <code>AskIdScreen</code> para solicitar el ID y asigna <code>notification_delete_task</code> como callback.</p> Source code in <code>controllers/interface.py</code> <pre><code>def action_delete_task(self) -&gt; None:\n    \"\"\"Maneja el atajo 'd' para eliminar una tarea.\n\n    Abre la pantalla modal `AskIdScreen` para solicitar el ID y asigna\n    `notification_delete_task` como callback.\n    \"\"\"\n    self.push_screen(AskIdScreen(), self.notification_delete_task)\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.action_edit_task","title":"<code>action_edit_task()</code>","text":"<p>Maneja el atajo 'e' para iniciar la edici\u00f3n de una tarea.</p> <p>Abre <code>AskIdScreen</code> para obtener el ID de la tarea a editar y asigna <code>_start_edit_process</code> como callback.</p> Source code in <code>controllers/interface.py</code> <pre><code>def action_edit_task(self) -&gt; None:\n    \"\"\"Maneja el atajo 'e' para iniciar la edici\u00f3n de una tarea.\n\n    Abre `AskIdScreen` para obtener el ID de la tarea a editar y asigna\n    `_start_edit_process` como callback.\n    \"\"\"\n    self.push_screen(\n        AskIdScreen(),\n        self._start_edit_process\n    )\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.action_filter_tasks","title":"<code>action_filter_tasks()</code>","text":"<p>Maneja el atajo 'f' para filtrar tareas.</p> <p>Abre la pantalla modal <code>FilterTasksScreen</code> y asigna <code>notification_filter_tasks</code> como callback.</p> Source code in <code>controllers/interface.py</code> <pre><code>def action_filter_tasks(self) -&gt; None:\n    \"\"\"Maneja el atajo 'f' para filtrar tareas.\n\n    Abre la pantalla modal `FilterTasksScreen` y asigna\n    `notification_filter_tasks` como callback.\n    \"\"\"\n    self.push_screen(\n        FilterTasksScreen(), \n        self.notification_filter_tasks\n    )\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.action_reset_filters","title":"<code>action_reset_filters()</code>","text":"<p>Maneja el atajo 'r' para limpiar filtros y refrescar la tabla.</p> <p>Llama directamente a <code>_update_table()</code> para recargar la lista completa de tareas.</p> Source code in <code>controllers/interface.py</code> <pre><code>def action_reset_filters(self) -&gt; None:\n    \"\"\"Maneja el atajo 'r' para limpiar filtros y refrescar la tabla.\n\n    Llama directamente a `_update_table()` para recargar la lista\n    completa de tareas.\n    \"\"\"\n    self._update_table()\n    self.app.notify(\n        \"Filtros limpiados. Mostrando todas las tareas.\"\n    )\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.action_view_details","title":"<code>action_view_details()</code>","text":"<p>Maneja el atajo 'v' para ver los detalles de una tarea.</p> <p>Abre <code>AskIdScreen</code> para obtener el ID y asigna <code>_show_details_screen</code> como callback.</p> Source code in <code>controllers/interface.py</code> <pre><code>def action_view_details(self) -&gt; None:\n    \"\"\"Maneja el atajo 'v' para ver los detalles de una tarea.\n\n    Abre `AskIdScreen` para obtener el ID y asigna `_show_details_screen`\n    como callback.\n    \"\"\"\n    self.push_screen(\n        AskIdScreen(),\n        self._show_details_screen\n    )\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.compose","title":"<code>compose()</code>","text":"<p>Compone el layout inicial de la aplicaci\u00f3n.</p> <p>Este m\u00e9todo de Textual se llama una vez al iniciar la app para renderizar los widgets est\u00e1ticos como el Header, Footer y DataTable.</p> Source code in <code>controllers/interface.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compone el layout inicial de la aplicaci\u00f3n.\n\n    Este m\u00e9todo de Textual se llama una vez al iniciar la app para\n    renderizar los widgets est\u00e1ticos como el Header, Footer y DataTable.\n    \"\"\"\n    leyenda_texto_status = Text()\n    leyenda_texto_priority = Text()\n    leyenda_texto_notas = Text()\n    dinamic_status_colors(leyenda_texto_status)\n    dinamic_priority_colors(leyenda_texto_priority)\n    dinamic_notes_leyend(leyenda_texto_notas)\n    yield Header()\n    yield Static(leyenda_texto_status, id=\"leyenda\")\n    yield Static(leyenda_texto_priority, id=\"prioridad\")\n    yield Static(leyenda_texto_notas, id=\"notas\")\n    yield DataTable()\n    yield Footer()\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.notification_add_task","title":"<code>notification_add_task(new_task_data)</code>","text":"<p>Callback que procesa los datos recibidos de <code>AddTaskScreen</code>.</p> <p>Este m\u00e9todo es llamado por Textual cuando la pantalla <code>AddTaskScreen</code> se cierra. Valida los datos, utiliza <code>TaskService</code> para crear la tarea y actualiza la tabla visual.</p> <p>Parameters:</p> Name Type Description Default <code>new_task_data</code> <code>dict | None</code> <p>Diccionario con los datos de la tarea enviado desde el modal. Es <code>None</code> si el usuario cancel\u00f3 la operaci\u00f3n.</p> required Source code in <code>controllers/interface.py</code> <pre><code>def notification_add_task(self, new_task_data: dict | None) -&gt; None:\n    \"\"\"Callback que procesa los datos recibidos de `AddTaskScreen`.\n\n    Este m\u00e9todo es llamado por Textual cuando la pantalla `AddTaskScreen`\n    se cierra.\n    Valida los datos, utiliza `TaskService` para crear la tarea y actualiza\n    la tabla visual.\n\n    Args:\n        new_task_data (dict | None): Diccionario con los datos de la\n            tarea enviado desde el modal. Es `None` si el usuario cancel\u00f3\n            la operaci\u00f3n.\n    \"\"\"\n    if new_task_data:\n        if not new_task_data[\"content\"]:\n            self.app.notify(\n                \"El contenido no puede estar vac\u00edo.\",\n                title=\"Error\",\n                severity=\"error\"\n            )\n            return\n        service = TaskService()\n        service.new_task_service(Task(**new_task_data))\n        self.app.notify(\n            f\"Tarea '{new_task_data['content']}' agregada.\",\n            title=\"Nueva Tarea\"\n        )\n        self._update_table()\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.notification_check_or_uncheck_task","title":"<code>notification_check_or_uncheck_task(task_id)</code>","text":"<p>Callback que cambia el estado de la tarea.</p> <p>Es llamado por Textual al cerrar <code>AskIdScreen</code>. Utiliza <code>TaskService</code> para cambiar el estado de la tarea y refresca la tabla.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea a modificar, validado por el decorador <code>@require_valid_id</code>.</p> required Source code in <code>controllers/interface.py</code> <pre><code>@require_valid_id\ndef notification_check_or_uncheck_task(self, task_id: int) -&gt; None:\n    \"\"\"Callback que cambia el estado de la tarea.\n\n    Es llamado por Textual al cerrar `AskIdScreen`. Utiliza `TaskService`\n    para cambiar el estado de la tarea y refresca la tabla.\n\n    Args:\n        task_id (int): ID de la tarea a modificar, validado por el\n            decorador `@require_valid_id`.\n    \"\"\"\n    service = TaskService()\n    service.check_or_uncheck_task_service(task_id)\n    self.app.notify(\n        f\"Tarea ID: {task_id} ha cambiado de estado.\",\n        title=\"Status Actualizado\"\n    )\n    self._update_table()\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.notification_delete_task","title":"<code>notification_delete_task(task_id)</code>","text":"<p>Callback que elimina la tarea especificada.</p> <p>Es llamado por Textual al cerrar <code>AskIdScreen</code>. Emplea <code>TaskService</code> para eliminar la tarea y actualiza la tabla.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea a eliminar, validado por el  decorador <code>@require_valid_id</code>.</p> required Source code in <code>controllers/interface.py</code> <pre><code>@require_valid_id\ndef notification_delete_task(self, task_id: int) -&gt; None:\n    \"\"\"Callback que elimina la tarea especificada.\n\n    Es llamado por Textual al cerrar `AskIdScreen`. Emplea `TaskService`\n    para eliminar la tarea y actualiza la tabla.\n\n    Args:\n        task_id (int): ID de la tarea a eliminar, validado por el\n             decorador `@require_valid_id`.\n    \"\"\"\n    service = TaskService()\n    service.delete_task_service(task_id)\n    self.app.notify(\n        f\"Tarea ID: {task_id} Eliminada.\", \n        title=\"Tarea Eliminada\", \n        severity=\"warning\"\n    )\n    self._update_table()\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.notification_filter_tasks","title":"<code>notification_filter_tasks(filter_data)</code>","text":"<p>Callback que recibe los criterios de filtro y actualiza la tabla.</p> <p>Limpia y estandariza los datos del filtro, llama al servicio para obtener las tareas filtradas y actualiza el <code>DataTable</code> con los resultados.</p> <p>Parameters:</p> Name Type Description Default <code>filter_data</code> <code>dict | None</code> <p>Diccionario con los filtros a aplicar. Ej: <code>{'status': 'pending', 'priority': 'alta'}</code>. Es <code>None</code> si el usuario cancel\u00f3 la pantalla de filtros.</p> required Source code in <code>controllers/interface.py</code> <pre><code>def notification_filter_tasks(self, filter_data: dict | None) -&gt; None:\n    \"\"\"Callback que recibe los criterios de filtro y actualiza la tabla.\n\n    Limpia y estandariza los datos del filtro, llama al servicio para\n    obtener las tareas filtradas y actualiza el `DataTable` con los\n    resultados.\n\n    Args:\n        filter_data (dict | None): Diccionario con los filtros a aplicar.\n            Ej: `{'status': 'pending', 'priority': 'alta'}`.\n            Es `None` si el usuario cancel\u00f3 la pantalla de filtros.\n    \"\"\"\n    if filter_data:\n        # 1. formato para el diccionario: si un valor est\u00e1 vac\u00edo se\n        # convierte a None para que el servicio no lo use como filtro.\n        filters = {\n            key: value if value else None\n            for key, value in filter_data.items()\n        }\n\n        # 2. Llamada al servicio con los filtros desempaquetados.\n        service = TaskService()\n        filtered_tasks_objects = service.filter_tasks_service(**filters)\n\n        # 3. Formateo de los resultados para la tabla\n        # (incluyendo cabeceras).\n        headers = (\"ID\", \"Status\", \"Tag\", \"Contenido\", \"Prioridad\")\n        results_for_ui: list[Any] = [headers]\n        for task in filtered_tasks_objects:\n            results_for_ui.append(\n                (task.id,\n                 task.status,\n                 task.tag,\n                 task.content,\n                 task.priority\n                 )\n            )\n\n        # 4. Actualizaci\u00f3n de la tabla con los datos filtrados.\n        table = self.query_one(DataTable)\n        # Limpia las filas anteriores.\n        table.clear()\n\n        # A\u00f1adimos solo las filas filtradas\n        for row_data in results_for_ui[1:]:\n            styled_row = list(row_data)\n            status_texto = styled_row[1]\n            prioridad_texto = styled_row[4]\n            styled_status = get_status_style(status_texto)\n            if isinstance(styled_status, Text):\n                styled_status.justify = \"center\"\n            styled_priority = get_priority_style(prioridad_texto)\n            if isinstance(styled_priority, Text):\n                styled_priority.justify = \"center\"\n            styled_row[1] = styled_status\n            styled_row[4] = styled_priority\n            table.add_row(*styled_row)\n\n        self.app.notify(\n            f\"Mostrando {len(filtered_tasks_objects)} tareas filtradas.\"\n        )\n</code></pre>"},{"location":"referencia_api/controllers/interface/#controllers.interface.Interface.on_mount","title":"<code>on_mount()</code>","text":"<p>Se ejecuta cuando la app se monta en el DOM.</p> <p>Este m\u00e9todo de Textual se usa para realizar configuraciones iniciales, como definir las cabeceras de la tabla y cargar los datos por primera vez.</p> Source code in <code>controllers/interface.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"Se ejecuta cuando la app se monta en el DOM.\n\n    Este m\u00e9todo de Textual se usa para realizar configuraciones iniciales,\n    como definir las cabeceras de la tabla y cargar los datos por primera vez.\n    \"\"\"\n    table = self.query_one(DataTable)\n    table.cursor_type = \"row\"\n    headers = (\"ID\", \"Status\", \"Tag\", \"Contenido\", \"Prioridad\", \"Notas\")\n\n    for label in headers:\n        if label == \"Contenido\":\n            table.add_column(label, width=90)\n        elif label == \"Tag\":\n            table.add_column(label, width=20)\n        elif label == \"Nota\":\n            table.add_column(label, width=10)\n        else:\n            table.add_column(label)\n    self._update_table()\n</code></pre>"},{"location":"referencia_api/controllers/screens/","title":"Controlador: Pantallas Modales","text":""},{"location":"referencia_api/controllers/screens/#controllersscreens","title":"<code>controllers.screens</code>","text":"<p>Este m\u00f3dulo define las pantallas modales reutilizables de la aplicaci\u00f3n.</p> <p> </p>"},{"location":"referencia_api/controllers/screens/#clase-askidscreen","title":"Clase <code>AskIdScreen</code>","text":"<p>               Bases: <code>ModalScreen</code></p> <p>Pantalla modal para preguntar por el ID de la tarea.</p> Esta pantalla es usada en las funciones de <ul> <li>check_uncheck_task: cambiar estatus de tarea.</li> <li>edita_task: editar tarea.</li> <li>delete_task: eliminar tarea.</li> </ul> Source code in <code>controllers/screens.py</code> <pre><code>class AskIdScreen(ModalScreen):\n    \"\"\"Pantalla modal para preguntar por el ID de la tarea.\n\n    Esta pantalla es usada en las funciones de:\n        - check_uncheck_task: cambiar estatus de tarea.\n        - edita_task: editar tarea.\n        - delete_task: eliminar tarea.\n    \"\"\"\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compone la UI de la pantalla.\n\n        Define la estructura visual de la pantalla, que consiste\n        en un contenedor vertical que alinea una etiqueta que pide el ID y un\n        campo de entrada para que el usuario lo introduzca.\n\n        Returns:\n            ComposeResult: Objeto que describe la composici\u00f3n de widgets que\n                Textual renderizar\u00e1.\n        \"\"\"\n        with Vertical(classes=\"dialog\"):\n            yield Label(\n                \"Introduce el ID de la tarea y presiona Enter:\", \n                classes=\"label\"\n            )\n            yield Input(id=\"id_input\")\n\n\n    def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n        \"\"\"Gestiona el env\u00edo del Input y cierra la pantalla devolviendo el\n        valor ingresado.\n\n        Este callback de Textual se activa al presionar Enter. El valor del Input\n        se pasa al m\u00e9todo `dismiss()`, que lo devuelve a quien llam\u00f3 la pantalla.\n\n        Args:\n            event (Input.Submitted): Evento que contiene el valor del Input.\n        \"\"\"\n        self.dismiss(event.value)\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.AskIdScreen.compose","title":"<code>compose()</code>","text":"<p>Compone la UI de la pantalla.</p> <p>Define la estructura visual de la pantalla, que consiste en un contenedor vertical que alinea una etiqueta que pide el ID y un campo de entrada para que el usuario lo introduzca.</p> <p>Returns:</p> Name Type Description <code>ComposeResult</code> <code>ComposeResult</code> <p>Objeto que describe la composici\u00f3n de widgets que Textual renderizar\u00e1.</p> Source code in <code>controllers/screens.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compone la UI de la pantalla.\n\n    Define la estructura visual de la pantalla, que consiste\n    en un contenedor vertical que alinea una etiqueta que pide el ID y un\n    campo de entrada para que el usuario lo introduzca.\n\n    Returns:\n        ComposeResult: Objeto que describe la composici\u00f3n de widgets que\n            Textual renderizar\u00e1.\n    \"\"\"\n    with Vertical(classes=\"dialog\"):\n        yield Label(\n            \"Introduce el ID de la tarea y presiona Enter:\", \n            classes=\"label\"\n        )\n        yield Input(id=\"id_input\")\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.AskIdScreen.on_input_submitted","title":"<code>on_input_submitted(event)</code>","text":"<p>Gestiona el env\u00edo del Input y cierra la pantalla devolviendo el valor ingresado.</p> <p>Este callback de Textual se activa al presionar Enter. El valor del Input se pasa al m\u00e9todo <code>dismiss()</code>, que lo devuelve a quien llam\u00f3 la pantalla.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Submitted</code> <p>Evento que contiene el valor del Input.</p> required Source code in <code>controllers/screens.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"Gestiona el env\u00edo del Input y cierra la pantalla devolviendo el\n    valor ingresado.\n\n    Este callback de Textual se activa al presionar Enter. El valor del Input\n    se pasa al m\u00e9todo `dismiss()`, que lo devuelve a quien llam\u00f3 la pantalla.\n\n    Args:\n        event (Input.Submitted): Evento que contiene el valor del Input.\n    \"\"\"\n    self.dismiss(event.value)\n</code></pre>"},{"location":"referencia_api/controllers/screens/#clase-addtaskscreen","title":"Clase <code>AddTaskScreen</code>","text":"<p>               Bases: <code>ModalScreen</code></p> <p>Pantalla modal para a\u00f1adir una nueva tarea.</p> <p>Solicita al usuario todos los datos necesarios para crear una nueva tarea. Es un componente espec\u00edfico para la funcionalidad de nueva tarea.</p> Source code in <code>controllers/screens.py</code> <pre><code>class AddTaskScreen(ModalScreen):\n    \"\"\"Pantalla modal para a\u00f1adir una nueva tarea.\n\n    Solicita al usuario todos los datos necesarios para crear una nueva tarea.\n    Es un componente espec\u00edfico para la funcionalidad de nueva tarea.\n    \"\"\"\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compone la UI de la pantalla.\"\"\"\n        with Vertical(classes=\"dialog\"):\n            yield Label(\"Contenido de la tarea:\")\n            yield Input(id=\"content_input\", placeholder=\"Descripci\u00f3n...\")\n            yield Label(\"Tag (personal, proyecto, trabajo, calendario):\")\n            yield Input(id=\"tag_input\", value=\"personal\")\n            yield Label(\"Prioridad (baja, media, alta):\")\n            yield Input(id=\"priority_input\", value=\"baja\")\n            yield Label(\"Detalles (opcional):\")\n            yield TextArea(\n                id=\"details_input\",\n                placeholder=\"Notas adicionales...\"\n            )\n            with Horizontal(classes=\"buttons\"):\n                yield Button(\"Crear Tarea\", variant=\"primary\", id=\"submit\")\n                yield Button(\"Cancelar\", id=\"cancel\")\n\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"Gestiona la pulsaci\u00f3n de los botones 'Crear Tarea' y 'Cancelar'.\n\n        Si se presiona 'submit', recopila los datos de los widgets Input y\n        TextArea en un diccionario y lo devuelve al cerrar la pantalla.\n        Si se presiona 'cancel', cierra la pantalla devolviendo `None`.\n\n        Args:\n            event (Button.Pressed): Evento que identifica bot\u00f3n presionado.\n        \"\"\"\n        if event.button.id == \"submit\":\n            new_task_data = {\n                \"content\": self.query_one(\"#content_input\", Input).value,\n                \"tag\": self.query_one(\"#tag_input\", Input).value,\n                \"priority\": self.query_one(\"#priority_input\", Input).value,\n                \"details\": self.query_one(\"#details_input\", TextArea).text,\n            }\n            self.dismiss(new_task_data)\n        else:\n            self.dismiss(None)\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.AddTaskScreen.compose","title":"<code>compose()</code>","text":"<p>Compone la UI de la pantalla.</p> Source code in <code>controllers/screens.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compone la UI de la pantalla.\"\"\"\n    with Vertical(classes=\"dialog\"):\n        yield Label(\"Contenido de la tarea:\")\n        yield Input(id=\"content_input\", placeholder=\"Descripci\u00f3n...\")\n        yield Label(\"Tag (personal, proyecto, trabajo, calendario):\")\n        yield Input(id=\"tag_input\", value=\"personal\")\n        yield Label(\"Prioridad (baja, media, alta):\")\n        yield Input(id=\"priority_input\", value=\"baja\")\n        yield Label(\"Detalles (opcional):\")\n        yield TextArea(\n            id=\"details_input\",\n            placeholder=\"Notas adicionales...\"\n        )\n        with Horizontal(classes=\"buttons\"):\n            yield Button(\"Crear Tarea\", variant=\"primary\", id=\"submit\")\n            yield Button(\"Cancelar\", id=\"cancel\")\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.AddTaskScreen.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Gestiona la pulsaci\u00f3n de los botones 'Crear Tarea' y 'Cancelar'.</p> <p>Si se presiona 'submit', recopila los datos de los widgets Input y TextArea en un diccionario y lo devuelve al cerrar la pantalla. Si se presiona 'cancel', cierra la pantalla devolviendo <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Pressed</code> <p>Evento que identifica bot\u00f3n presionado.</p> required Source code in <code>controllers/screens.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Gestiona la pulsaci\u00f3n de los botones 'Crear Tarea' y 'Cancelar'.\n\n    Si se presiona 'submit', recopila los datos de los widgets Input y\n    TextArea en un diccionario y lo devuelve al cerrar la pantalla.\n    Si se presiona 'cancel', cierra la pantalla devolviendo `None`.\n\n    Args:\n        event (Button.Pressed): Evento que identifica bot\u00f3n presionado.\n    \"\"\"\n    if event.button.id == \"submit\":\n        new_task_data = {\n            \"content\": self.query_one(\"#content_input\", Input).value,\n            \"tag\": self.query_one(\"#tag_input\", Input).value,\n            \"priority\": self.query_one(\"#priority_input\", Input).value,\n            \"details\": self.query_one(\"#details_input\", TextArea).text,\n        }\n        self.dismiss(new_task_data)\n    else:\n        self.dismiss(None)\n</code></pre>"},{"location":"referencia_api/controllers/screens/#clase-asktaskedit","title":"Clase <code>AskTaskEdit</code>","text":"<p>               Bases: <code>ModalScreen</code></p> <p>Pantalla modal para EDITAR una tarea existente.</p> Source code in <code>controllers/screens.py</code> <pre><code>class AskTaskEdit(ModalScreen):\n    \"\"\"Pantalla modal para EDITAR una tarea existente.\"\"\"\n\n    def __init__(self, task_to_edit: Task):\n        \"\"\"Inicializa la pantalla de edici\u00f3n con los datos de una tarea\n        existente.\n\n        Args:\n            task_to_edit (Task): Objeto de la tarea que se va a editar.\n                Sus datos se usar\u00e1n para pre-rellenar los campos de la pantalla.\n        \"\"\"\n        super().__init__()\n        self.task_to_edit = task_to_edit\n\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compone la UI de la pantalla.\"\"\"\n        with Vertical(classes=\"dialog\"):\n            yield Label(f\"Editando Tarea ID: {self.task_to_edit.id}\")\n            yield Label(\"Contenido de la tarea:\")\n            yield Input(id=\"content_input\", value=self.task_to_edit.content)\n            yield Label(\"Tag (personal, proyecto, trabajo, calendario):\")\n            yield Input(id=\"tag_input\", value=self.task_to_edit.tag)\n            yield Label(\"Prioridad (baja, media, alta):\")\n            yield Input(id=\"priority_input\", value=self.task_to_edit.priority)\n            yield Label(\"Detalles (opcional):\")\n            initial_text = self.task_to_edit.details if self.task_to_edit.details else \"\"\n            yield TextArea(initial_text, id=\"details_input\")\n\n            with Horizontal(classes=\"buttons\"):\n                yield Button(\"Guardar Cambios\", variant=\"primary\", id=\"submit\")\n                yield Button(\"Cancelar\", id=\"cancel\")\n\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"Gestiona los botones 'Guardar Cambios' y 'Cancelar'.\n\n        Si se presiona 'submit', recopila los datos actualizados, a\u00f1ade el ID\n        de la tarea al diccionario y lo devuelve al cerrar la pantalla.\n        Si se presiona 'cancel', cierra la pantalla devolviendo `None`.\n\n        Args:\n            event (Button.Pressed): Evento que identifica bot\u00f3n presionado.\n        \"\"\"\n        if event.button.id == \"submit\":\n            updated_data: dict[str, Any] = {\n                \"content\": self.query_one(\"#content_input\", Input).value,\n                \"tag\": self.query_one(\"#tag_input\", Input).value,\n                \"priority\": self.query_one(\"#priority_input\", Input).value,\n                \"details\": self.query_one(\"#details_input\", TextArea).text,\n            }\n            if self.task_to_edit:\n                updated_data[\"id\"] = self.task_to_edit.id\n            self.dismiss(updated_data)\n        else:\n            self.dismiss(None)\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.AskTaskEdit.__init__","title":"<code>__init__(task_to_edit)</code>","text":"<p>Inicializa la pantalla de edici\u00f3n con los datos de una tarea existente.</p> <p>Parameters:</p> Name Type Description Default <code>task_to_edit</code> <code>Task</code> <p>Objeto de la tarea que se va a editar. Sus datos se usar\u00e1n para pre-rellenar los campos de la pantalla.</p> required Source code in <code>controllers/screens.py</code> <pre><code>def __init__(self, task_to_edit: Task):\n    \"\"\"Inicializa la pantalla de edici\u00f3n con los datos de una tarea\n    existente.\n\n    Args:\n        task_to_edit (Task): Objeto de la tarea que se va a editar.\n            Sus datos se usar\u00e1n para pre-rellenar los campos de la pantalla.\n    \"\"\"\n    super().__init__()\n    self.task_to_edit = task_to_edit\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.AskTaskEdit.compose","title":"<code>compose()</code>","text":"<p>Compone la UI de la pantalla.</p> Source code in <code>controllers/screens.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compone la UI de la pantalla.\"\"\"\n    with Vertical(classes=\"dialog\"):\n        yield Label(f\"Editando Tarea ID: {self.task_to_edit.id}\")\n        yield Label(\"Contenido de la tarea:\")\n        yield Input(id=\"content_input\", value=self.task_to_edit.content)\n        yield Label(\"Tag (personal, proyecto, trabajo, calendario):\")\n        yield Input(id=\"tag_input\", value=self.task_to_edit.tag)\n        yield Label(\"Prioridad (baja, media, alta):\")\n        yield Input(id=\"priority_input\", value=self.task_to_edit.priority)\n        yield Label(\"Detalles (opcional):\")\n        initial_text = self.task_to_edit.details if self.task_to_edit.details else \"\"\n        yield TextArea(initial_text, id=\"details_input\")\n\n        with Horizontal(classes=\"buttons\"):\n            yield Button(\"Guardar Cambios\", variant=\"primary\", id=\"submit\")\n            yield Button(\"Cancelar\", id=\"cancel\")\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.AskTaskEdit.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Gestiona los botones 'Guardar Cambios' y 'Cancelar'.</p> <p>Si se presiona 'submit', recopila los datos actualizados, a\u00f1ade el ID de la tarea al diccionario y lo devuelve al cerrar la pantalla. Si se presiona 'cancel', cierra la pantalla devolviendo <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Pressed</code> <p>Evento que identifica bot\u00f3n presionado.</p> required Source code in <code>controllers/screens.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Gestiona los botones 'Guardar Cambios' y 'Cancelar'.\n\n    Si se presiona 'submit', recopila los datos actualizados, a\u00f1ade el ID\n    de la tarea al diccionario y lo devuelve al cerrar la pantalla.\n    Si se presiona 'cancel', cierra la pantalla devolviendo `None`.\n\n    Args:\n        event (Button.Pressed): Evento que identifica bot\u00f3n presionado.\n    \"\"\"\n    if event.button.id == \"submit\":\n        updated_data: dict[str, Any] = {\n            \"content\": self.query_one(\"#content_input\", Input).value,\n            \"tag\": self.query_one(\"#tag_input\", Input).value,\n            \"priority\": self.query_one(\"#priority_input\", Input).value,\n            \"details\": self.query_one(\"#details_input\", TextArea).text,\n        }\n        if self.task_to_edit:\n            updated_data[\"id\"] = self.task_to_edit.id\n        self.dismiss(updated_data)\n    else:\n        self.dismiss(None)\n</code></pre>"},{"location":"referencia_api/controllers/screens/#clase-filtertasksscreen","title":"Clase <code>FilterTasksScreen</code>","text":"<p>               Bases: <code>ModalScreen</code></p> <p>Pantalla modal para filtrar tareas.</p> Source code in <code>controllers/screens.py</code> <pre><code>class FilterTasksScreen(ModalScreen):\n    \"\"\"Pantalla modal para filtrar tareas.\"\"\"\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compone la UI de la pantalla.\"\"\"\n        with Vertical(classes=\"dialog\"):\n            yield Label(\n                \"Filtrar Tareas (deja en blanco para no usar un filtro)\",\n                id=\"filter_label_1\"\n            )\n\n            yield Label(\n                \"Filtrar por Status (pending, in_progress, completed):\",\n                id=\"filter_label_2\"\n            )\n            yield Input(id=\"status_filter\", placeholder=\"E.g., pending\")\n\n            yield Label(\"Filtrar por Tag:\", id=\"filter_label_3\")\n            yield Input(id=\"tag_filter\", placeholder=\"E.g., personal\")\n\n            yield Label(\"Filtrar por Prioridad (baja, media, alta):\",\n                        id=\"filter_label_4\")\n            yield Input(id=\"priority_filter\", placeholder=\"E.g., alta\")\n\n            with Horizontal(classes=\"buttons\"):\n                yield Button(\"Filtrar\", variant=\"primary\", id=\"submit\")\n                yield Button(\"Cancelar\", id=\"cancel\")\n\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"Gestiona los botones 'Filtrar' y 'Cancelar'.\n\n        Si se presiona 'submit', recopila los criterios de los campos de texto\n        en un diccionario y lo devuelve al cerrar la pantalla.\n        Si se presiona 'cancel', cierra la pantalla devolviendo `None`.\n\n        Args:\n            event (Button.Pressed): Evento que identifica bot\u00f3n presionado.\n        \"\"\"\n        if event.button.id == \"submit\":\n            # Recopilamos los criterios de filtro en un diccionario\n            filter_data = {\n                \"status\": self.query_one(\"#status_filter\", Input).value,\n                \"tag\": self.query_one(\"#tag_filter\", Input).value,\n                \"priority\": self.query_one(\"#priority_filter\", Input).value,\n            }\n            # Cerramos la pantalla y pasamos los criterios\n            self.dismiss(filter_data)\n        else:\n            self.dismiss(None)\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.FilterTasksScreen.compose","title":"<code>compose()</code>","text":"<p>Compone la UI de la pantalla.</p> Source code in <code>controllers/screens.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compone la UI de la pantalla.\"\"\"\n    with Vertical(classes=\"dialog\"):\n        yield Label(\n            \"Filtrar Tareas (deja en blanco para no usar un filtro)\",\n            id=\"filter_label_1\"\n        )\n\n        yield Label(\n            \"Filtrar por Status (pending, in_progress, completed):\",\n            id=\"filter_label_2\"\n        )\n        yield Input(id=\"status_filter\", placeholder=\"E.g., pending\")\n\n        yield Label(\"Filtrar por Tag:\", id=\"filter_label_3\")\n        yield Input(id=\"tag_filter\", placeholder=\"E.g., personal\")\n\n        yield Label(\"Filtrar por Prioridad (baja, media, alta):\",\n                    id=\"filter_label_4\")\n        yield Input(id=\"priority_filter\", placeholder=\"E.g., alta\")\n\n        with Horizontal(classes=\"buttons\"):\n            yield Button(\"Filtrar\", variant=\"primary\", id=\"submit\")\n            yield Button(\"Cancelar\", id=\"cancel\")\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.FilterTasksScreen.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Gestiona los botones 'Filtrar' y 'Cancelar'.</p> <p>Si se presiona 'submit', recopila los criterios de los campos de texto en un diccionario y lo devuelve al cerrar la pantalla. Si se presiona 'cancel', cierra la pantalla devolviendo <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Pressed</code> <p>Evento que identifica bot\u00f3n presionado.</p> required Source code in <code>controllers/screens.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Gestiona los botones 'Filtrar' y 'Cancelar'.\n\n    Si se presiona 'submit', recopila los criterios de los campos de texto\n    en un diccionario y lo devuelve al cerrar la pantalla.\n    Si se presiona 'cancel', cierra la pantalla devolviendo `None`.\n\n    Args:\n        event (Button.Pressed): Evento que identifica bot\u00f3n presionado.\n    \"\"\"\n    if event.button.id == \"submit\":\n        # Recopilamos los criterios de filtro en un diccionario\n        filter_data = {\n            \"status\": self.query_one(\"#status_filter\", Input).value,\n            \"tag\": self.query_one(\"#tag_filter\", Input).value,\n            \"priority\": self.query_one(\"#priority_filter\", Input).value,\n        }\n        # Cerramos la pantalla y pasamos los criterios\n        self.dismiss(filter_data)\n    else:\n        self.dismiss(None)\n</code></pre>"},{"location":"referencia_api/controllers/screens/#clase-viewdetailsscreen","title":"Clase <code>ViewDetailsScreen</code>","text":"<p>               Bases: <code>ModalScreen</code></p> <p>Pantalla modal para mostrar los detalles de una tarea en Markdown.</p> Source code in <code>controllers/screens.py</code> <pre><code>class ViewDetailsScreen(ModalScreen):\n    \"\"\"Pantalla modal para mostrar los detalles de una tarea en Markdown.\"\"\"\n\n    def __init__(self, details_content: str, task_id: int):\n        \"\"\"Inicializa la pantalla de visualizaci\u00f3n de detalles.\n\n        Args:\n            details_content (str): Contenido de los detalles de la tarea,\n                que puede contener formato Markdown.\n            task_id (int): ID de la tarea, usado para mostrarlo en el t\u00edtulo.\n        \"\"\"\n        super().__init__()\n        self.details_content = details_content\n        self.task_id = task_id\n\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"Compone la UI de la pantalla.\"\"\"\n        with Vertical(classes=\"dialog\"):\n            yield Label(f\"Detalles de la Tarea ID: {self.task_id}\")\n\n            # El widget de Markdown renderizar\u00e1 el texto.\n            # Si no hay detalles, muestra un mensaje por defecto.\n            markdown_text = self.details_content or \"*No hay detalles para esta tarea.*\"\n            with Vertical(id=\"markdown_container\"):\n                yield Markdown(markdown_text)\n\n            with Horizontal(classes=\"buttons\"):\n                yield Button(\"Cerrar\", variant=\"primary\", id=\"close_details\")\n\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"Cierra la pantalla modal cuando se presiona el bot\u00f3n 'Cerrar'.\"\"\"\n        self.dismiss()\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.ViewDetailsScreen.__init__","title":"<code>__init__(details_content, task_id)</code>","text":"<p>Inicializa la pantalla de visualizaci\u00f3n de detalles.</p> <p>Parameters:</p> Name Type Description Default <code>details_content</code> <code>str</code> <p>Contenido de los detalles de la tarea, que puede contener formato Markdown.</p> required <code>task_id</code> <code>int</code> <p>ID de la tarea, usado para mostrarlo en el t\u00edtulo.</p> required Source code in <code>controllers/screens.py</code> <pre><code>def __init__(self, details_content: str, task_id: int):\n    \"\"\"Inicializa la pantalla de visualizaci\u00f3n de detalles.\n\n    Args:\n        details_content (str): Contenido de los detalles de la tarea,\n            que puede contener formato Markdown.\n        task_id (int): ID de la tarea, usado para mostrarlo en el t\u00edtulo.\n    \"\"\"\n    super().__init__()\n    self.details_content = details_content\n    self.task_id = task_id\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.ViewDetailsScreen.compose","title":"<code>compose()</code>","text":"<p>Compone la UI de la pantalla.</p> Source code in <code>controllers/screens.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Compone la UI de la pantalla.\"\"\"\n    with Vertical(classes=\"dialog\"):\n        yield Label(f\"Detalles de la Tarea ID: {self.task_id}\")\n\n        # El widget de Markdown renderizar\u00e1 el texto.\n        # Si no hay detalles, muestra un mensaje por defecto.\n        markdown_text = self.details_content or \"*No hay detalles para esta tarea.*\"\n        with Vertical(id=\"markdown_container\"):\n            yield Markdown(markdown_text)\n\n        with Horizontal(classes=\"buttons\"):\n            yield Button(\"Cerrar\", variant=\"primary\", id=\"close_details\")\n</code></pre>"},{"location":"referencia_api/controllers/screens/#controllers.screens.ViewDetailsScreen.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Cierra la pantalla modal cuando se presiona el bot\u00f3n 'Cerrar'.</p> Source code in <code>controllers/screens.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Cierra la pantalla modal cuando se presiona el bot\u00f3n 'Cerrar'.\"\"\"\n    self.dismiss()\n</code></pre>"},{"location":"referencia_api/models/model_task/","title":"Modelo: Task","text":""},{"location":"referencia_api/models/model_task/#modelsmodel_task","title":"<code>models.model_task</code>","text":"<p>Este m\u00f3dulo define el modelo de datos principal para una Tarea.</p>"},{"location":"referencia_api/models/model_task/#clase-task","title":"Clase <code>Task</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Representa una \u00fanica tarea y define su esquema de datos.</p> <p>Utiliza Pydantic para la validaci\u00f3n autom\u00e1tica, asegurando que cualquier objeto <code>Task</code> en la aplicaci\u00f3n sea siempre consistente y contenga datos v\u00e1lidos.</p> <p>Attributes:</p> Name Type Description <code>-</code> <code>id (Optional[int]</code> <p>Identificador \u00fanico de la tarea, generado por la   base de datos. Es <code>None</code> para tareas nuevas a\u00fan no guardadas.</p> <code>-</code> <code>status (Status</code> <p>Estado actual de la tarea. Default: \"pending\".</p> <code>-</code> <code>tag (Tag</code> <p>La categor\u00eda o etiqueta de la tarea. Default: \"personal\".</p> <code>-</code> <code>content (str</code> <p>Descripci\u00f3n principal de lo que se debe hacer.</p> <code>-</code> <code>priority (Priority</code> <p>Nivel de prioridad de la tarea. Default: \"baja\".</p> <code>-</code> <code>details (Optional[str]</code> <p>Notas o informaci\u00f3n adicional sobre la   tarea, que puede contener formato Markdown. Default: <code>None</code>.</p>"},{"location":"referencia_api/models/model_task/#models.model_task.Task.__str__","title":"<code>__str__()</code>","text":"<p>Devuelve una representaci\u00f3n en cadena de la tarea para facilitar su lectura.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Cadena de caracteres con la informaci\u00f3n de la tarea.</p>"},{"location":"referencia_api/repositories/connection_manager/","title":"Repositorio: Connection Manager","text":""},{"location":"referencia_api/repositories/connection_manager/#repositoriesconnection_manager","title":"<code>repositories.connection_manager</code>","text":"<p>Este m\u00f3dulo proporciona el decorador <code>connection_manager</code> para la gesti\u00f3n autom\u00e1tica de conexiones a la base de datos.</p>"},{"location":"referencia_api/repositories/connection_manager/#decorador-connection_manager","title":"Decorador <code>connection_manager</code>","text":"<p>Gestiona el ciclo de vida de la conexi\u00f3n a la base de datos para un m\u00e9todo.</p> <p>Este decorador est\u00e1 dise\u00f1ado para envolver m\u00e9todos de una clase que necesitan interactuar con la base de datos. Se asume que la instancia de la clase (<code>self</code>) tiene un atributo <code>db_path</code> con la ruta al archivo de la base de datos.</p> <p>El decorador se encarga de: 1. Abrir una conexi\u00f3n a la base de datos usando <code>sqlite3.connect</code>. 2. Crear un cursor. 3. Ejecutar el m\u00e9todo decorado, inyect\u00e1ndole el <code>cursor</code> como un argumento    de palabra clave (keyword argument). 4. Cerrar el cursor de forma segura. 5. Hacer commit de la transacci\u00f3n si tiene \u00e9xito (impl\u00edcito en <code>with</code>). 6. Capturar y registrar cualquier <code>sqlite3.Error</code>, evitando que el programa    se detenga.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>El m\u00e9todo a decorar. Debe ser un m\u00e9todo de instancia y estar preparado para recibir un argumento de palabra clave <code>cursor</code>.</p> required <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[..., Any]</code> <p>El nuevo m\u00e9todo envuelto con la gesti\u00f3n de conexi\u00f3n.</p>"},{"location":"referencia_api/repositories/querys/","title":"Repositorio: Querys SQL","text":""},{"location":"referencia_api/repositories/querys/#repositoriesquerys","title":"<code>repositories.querys</code>","text":"<p>Este m\u00f3dulo act\u00faa como una \u00fanica fuente de verdad para todas las sentencias SQL utilizadas en la aplicaci\u00f3n.</p> <p>Centralizar las consultas aqu\u00ed facilita su mantenimiento, lectura y previene la dispersi\u00f3n de sentencias SQL a trav\u00e9s de la l\u00f3gica de      la aplicaci\u00f3n. Las constantes definidas en este m\u00f3dulo son importadas y utilizadas por <code>RepositoryDB</code>.</p>"},{"location":"referencia_api/repositories/repository_db/","title":"Repositorio: RepositoryDB","text":""},{"location":"referencia_api/repositories/repository_db/#repositoriesrepository_db","title":"<code>repositories.repository_db</code>","text":"<p>Este m\u00f3dulo define la capa de acceso a datos para la base de datos de tareas.</p>"},{"location":"referencia_api/repositories/repository_db/#clase-repositorydb","title":"Clase <code>RepositoryDB</code>","text":"<p>Gestiona todas las operaciones de la base de datos para las tareas.</p> <p>Esta clase abstrae las consultas SQL y proporciona una interfaz clara para que la capa de servicio interact\u00fae con la base de datos.</p>"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.__init__","title":"<code>__init__(db_name)</code>","text":"<p>Inicializa el repositorio y establece la ruta a la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>db_name</code> <code>str</code> <p>El nombre del archivo de la base de datos (ej. \"tasks-cli.db\").</p> required"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.task_format_list","title":"<code>task_format_list(rows_list)</code>","text":"<p>Convierte una lista de filas de la BD en una lista de objetos Task.</p> <p>Este m\u00e9todo auxiliar act\u00faa como una capa de mapeo, transformando los datos crudos de la base de datos (lista de tuplas) en una lista de objetos <code>Task</code> validados por Pydantic.</p> <p>Parameters:</p> Name Type Description Default <code>rows_list</code> <code>list</code> <p>Lista de filas (tuplas) obtenida de una consulta a la base de datos.</p> required <p>Returns:</p> Type Description <code>list[Task]</code> <p>list[Task]: Lista de objetos <code>Task</code> completamente formados.</p>"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.create_table","title":"<code>create_table(cursor=sqlite3.Cursor)</code>","text":"<p>Asegura que la tabla 'tasks_table' exista en la base de datos.</p> <p>Ejecuta la sentencia SQL para crear la tabla si esta no existe. La gesti\u00f3n de la conexi\u00f3n y el commit es manejada por el decorador.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p>Cursor de la base de datos, inyectado  por el decorador <code>connection_manager</code>.</p> <code>Cursor</code>"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.get_all_tasks","title":"<code>get_all_tasks(cursor)</code>","text":"<p>Recupera todas las tareas de la base de datos.</p> <p>Si la tabla no existe o hay un error, devuelve una lista vac\u00eda.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p>Cursor de la base de datos, inyectado  por el decorador.</p> required <p>Returns:</p> Type Description <code>list[Task]</code> <p>list[Task]: Una lista de objetos <code>Task</code> que representan todas las tareas en la base de datos. Estar\u00e1 vac\u00eda si sqlite3 devuelve error.</p>"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.new_task","title":"<code>new_task(task_instance, cursor)</code>","text":"<p>Inserta una nueva tarea en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>task_instance</code> <code>Task</code> <p>Objeto <code>Task</code> con los datos a insertar.</p> required <code>cursor</code> <code>Cursor</code> <p>Cursor de la base de datos, inyectado por el decorador.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>ID de la fila de la tarea reci\u00e9n creada.</p>"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.filter_tasks","title":"<code>filter_tasks(cursor, status=None, tag=None, priority=None)</code>","text":"<p>Filtra tareas din\u00e1micamente por status, tag y/o prioridad.</p> <p>Utiliza un patr\u00f3n Strategy para seleccionar la consulta SQL adecuada bas\u00e1ndose en los filtros proporcionados. Si no se proporciona ning\u00fan filtro, devuelve todas las tareas.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>Cursor</code> <p>Cursor de la base de datos, inyectado por el decorador.</p> required <code>status</code> <code>str | None</code> <p>Estado por el cual filtrar.</p> <code>None</code> <code>tag</code> <code>str | None</code> <p>Etiqueta por la cual filtrar.</p> <code>None</code> <code>priority</code> <code>str | None</code> <p>Prioridad por la cual filtrar.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Task]</code> <p>list[Task]: Lista de objetos <code>Task</code> que coinciden con los criterios de filtrado.</p>"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.update_task","title":"<code>update_task(task_id, new_data, cursor)</code>","text":"<p>Actualiza uno o m\u00e1s campos de una tarea existente de forma din\u00e1mica.</p> <p>Construye la sentencia SQL din\u00e1micamente a partir de los datos proporcionados en el diccionario <code>new_data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea a actualizar.</p> required <code>new_data</code> <code>dict[str, str]</code> <p>Diccionario con los campos a actualizar y sus nuevos valores. Ejemplo: {\"content\": \"Nuevo contenido\", \"priority\": \"alta\"}</p> required <code>cursor</code> <code>Cursor</code> <p>Cursor de la base de datos, inyectado por el decorador.</p> required"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.check_or_uncheck_task","title":"<code>check_or_uncheck_task(id_task, cursor)</code>","text":"<p>Cambia el estado de una tarea de forma c\u00edclica.</p> <p>Verifica primero si la tarea existe. Si existe, utiliza la consulta <code>UPDATE_STATUS_TOGGLE</code> para rotar el estado.</p> <p>Parameters:</p> Name Type Description Default <code>id_task</code> <code>int</code> <p>ID de la tarea cuyo estado se va a cambiar.</p> required <code>cursor</code> <code>Cursor</code> <p>Cursor de la base de datos, inyectado por el decorador.</p> required"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.get_task_by_id","title":"<code>get_task_by_id(id_task, cursor)</code>","text":"<p>Recupera una \u00fanica tarea por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>id_task</code> <code>int</code> <p>ID de la tarea a recuperar.</p> required <code>cursor</code> <code>Cursor</code> <p>Cursor de la base de datos, inyectado por el decorador.</p> required <p>Returns:</p> Type Description <code>Task | None</code> <p>Task | None: Objeto <code>Task</code> si se encuentra la tarea, o <code>None</code> si no existe ninguna tarea con ese ID.</p>"},{"location":"referencia_api/repositories/repository_db/#repositories.repository_db.RepositoryDB.delete_task","title":"<code>delete_task(id_task, cursor)</code>","text":"<p>Elimina una tarea de la base de datos por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>id_task</code> <code>int</code> <p>ID de la tarea a eliminar.</p> required <code>cursor</code> <code>Cursor</code> <p>Cursor de la base de datos, inyectado por el decorador.</p> required"},{"location":"referencia_api/services/task_service/","title":"Servicio: TaskService","text":""},{"location":"referencia_api/services/task_service/#servicestask_service","title":"<code>services.task_service</code>","text":"<p>Este m\u00f3dulo contiene la l\u00f3gica de negocio de la aplicaci\u00f3n.</p>"},{"location":"referencia_api/services/task_service/#clase-taskservice","title":"Clase <code>TaskService</code>","text":"<p>Gestiona las operaciones de alto nivel relacionadas con las tareas.</p> <p>Esta clase desacopla la interfaz de usuario de los detalles de la base de datos. Recibe solicitudes de la UI, aplica la l\u00f3gica de negocio y coordina las operaciones con la capa de repositorio.</p>"},{"location":"referencia_api/services/task_service/#services.task_service.TaskService.__init__","title":"<code>__init__()</code>","text":"<p>Inicializa el servicio de tareas.</p> <p>Crea una instancia del <code>RepositoryDB</code> para interactuar con la base de datos. El nombre de la base de datos est\u00e1 definido aqu\u00ed para configurar el repositorio que usar\u00e1 este servicio.</p>"},{"location":"referencia_api/services/task_service/#services.task_service.TaskService.check_or_uncheck_task_service","title":"<code>check_or_uncheck_task_service(task_id)</code>","text":"<p>Orquesta el cambio de estado c\u00edclico de una tarea.</p> <p>Delega la operaci\u00f3n de cambiar el estado de una tarea (ej. de 'pending' a 'in_progress') al repositorio.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea a modificar.</p> required"},{"location":"referencia_api/services/task_service/#services.task_service.TaskService.delete_task_service","title":"<code>delete_task_service(task_id)</code>","text":"<p>Procesa la eliminaci\u00f3n de una tarea por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea a eliminar.</p> required"},{"location":"referencia_api/services/task_service/#services.task_service.TaskService.filter_tasks_service","title":"<code>filter_tasks_service(status=None, tag=None, priority=None)</code>","text":"<p>Filtra las tareas seg\u00fan los criterios proporcionados.</p> <p>Pasa los criterios de filtro directamente al repositorio para que ejecute la consulta de b\u00fasqueda correspondiente.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str | None</code> <p>Estado por el cual filtrar.</p> <code>None</code> <code>tag</code> <code>str | None</code> <p>Etiqueta por la cual filtrar.</p> <code>None</code> <code>priority</code> <code>str | None</code> <p>Prioridad por la cual filtrar.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Task]</code> <p>list[Task]: Lista de objetos <code>Task</code> que coinciden con los criterios de filtrado.</p>"},{"location":"referencia_api/services/task_service/#services.task_service.TaskService.get_all_tasks","title":"<code>get_all_tasks()</code>","text":"<p>Recupera todas las tareas como objetos <code>Task</code> puros.</p> <p>Este m\u00e9todo se comunica con el repositorio para obtener una lista completa de las tareas, devolvi\u00e9ndolas como objetos de modelo sin formato.</p> <p>Returns:</p> Type Description <code>list[Task]</code> <p>list[Task]: Lista de objetos <code>Task</code>.</p>"},{"location":"referencia_api/services/task_service/#services.task_service.TaskService.get_task_by_id_service","title":"<code>get_task_by_id_service(task_id)</code>","text":"<p>Busca y devuelve una \u00fanica tarea por su ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea a buscar.</p> required <p>Returns:</p> Type Description <code>Task | None</code> <p>Task | None: Objeto <code>Task</code> si se encuentra, o <code>None</code> si no.</p>"},{"location":"referencia_api/services/task_service/#services.task_service.TaskService.get_tasks_for_ui","title":"<code>get_tasks_for_ui()</code>","text":"<p>Prepara y formatea los datos de las tareas para ser mostrados correctamente en la UI.</p> <p>A diferencia de <code>get_all_tasks</code>, este m\u00e9todo transforma la lista de objetos <code>Task</code> en un formato espec\u00edfico para el <code>DataTable</code> de Textual, incluyendo cabeceras y un indicador visual para las notas extras.</p> <p>Returns:</p> Type Description <code>list[tuple]</code> <p>list[tuple[Any, ...]: Lista de tuplas donde el primer elemento es la fila de cabeceras y los siguientes son las filas de tareas.</p>"},{"location":"referencia_api/services/task_service/#services.task_service.TaskService.new_task_service","title":"<code>new_task_service(task_instance)</code>","text":"<p>Procesa la creaci\u00f3n de una nueva tarea.</p> <p>Recibe un objeto <code>Task</code> desde la capa de control y lo pasa al repositorio para su inserci\u00f3n en la base de datos.</p> <p>Parameters:</p> Name Type Description Default <code>task_instance</code> <code>Task</code> <p>Objeto <code>Task</code> (sin ID) a crear.</p> required"},{"location":"referencia_api/services/task_service/#services.task_service.TaskService.update_task_service","title":"<code>update_task_service(task_id, new_data)</code>","text":"<p>Procesa la actualizaci\u00f3n de una tarea existente.</p> <p>Recibe el ID de la tarea y un diccionario con los nuevos datos, y se los pasa al repositorio para que aplique los cambios.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>int</code> <p>ID de la tarea a actualizar.</p> required <code>new_data</code> <code>dict[str, str]</code> <p>Diccionario con los campos a modificar y sus nuevos valores.</p> required"},{"location":"referencia_api/tests/models_tests/test_model_task/","title":"Pruebas: Modelo Task","text":""},{"location":"referencia_api/tests/models_tests/test_model_task/#testsmodels_teststest_model_task","title":"<code>tests.models_tests.test_model_task</code>","text":"<p>Este m\u00f3dulo contiene las pruebas unitarias para el modelo <code>Task</code>.</p> <p>Tests unitarios para la clase Task. total de pruebas: 10.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_and_without_details","title":"<code>test_task_creation_with_and_without_details()</code>","text":"<p>Comprueba la creaci\u00f3n de una instancia Tarea con y sin detalles.</p> <p>Verifica que el campo 'details' se asigna correctamente cuando se proporciona y que su valor por defecto es None cuando no se especifica.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_defaults","title":"<code>test_task_creation_with_defaults()</code>","text":"<p>Comprueba la creaci\u00f3n de una instancia Tarea con valores defaults.</p> <p>El test verifica que la creaci\u00f3n de una instancia de Task especificando s\u00f3lo el valor de content(contenido de la tarea o descripci\u00f3n), la tarea se crea correctamente con los valores por defecto en sus otras propiedades.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_invalid_content_type_boolean","title":"<code>test_task_creation_with_invalid_content_type_boolean()</code>","text":"<p>Comprueba error generado con content tipo booleano.</p> <p>El test verifica que si una tarea es generada con un valor de tipo boleano para su propiedad content, no ser\u00e1 generada.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>Cuando content es de tipo booleano.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_invalid_content_type_float","title":"<code>test_task_creation_with_invalid_content_type_float()</code>","text":"<p>Comprueba error generado con content tipo float.</p> <p>El presente test verifica que si una tarea se crea usando un valor de tipo float para la propiedad content, no ser\u00e1 creada.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>Cuando content es de tipo float.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_invalid_content_type_integer","title":"<code>test_task_creation_with_invalid_content_type_integer()</code>","text":"<p>Comprueba error generado con content tipo entero.</p> <p>Este test verifica que si el tipo de valor para la propiedad content resulta ser un entero, la tarea no ser\u00e1 generada.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>Cuando content es de tipo int.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_invalid_priority","title":"<code>test_task_creation_with_invalid_priority()</code>","text":"<p>Comprueba error generado con valor de prioridad inv\u00e1lida.</p> <p>El test verifica que si la tarea contiene un valor no permitido en la propiedad priority, no ser\u00e1 generada. Los valores permitidos est\u00e1n definidos en el m\u00f3dulo models/model_task.py en el objeto Literal Priority.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>Cuando el valor de prioridad no es uno de los permitidos.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_invalid_status","title":"<code>test_task_creation_with_invalid_status()</code>","text":"<p>Comprueba error con un status inv\u00e1lido.</p> <p>Este test verifica que si la tarea es creada con un valor de status no v\u00e1lido, la tarea no se crea. Los valores v\u00e1lidos se definen en el m\u00f3dulo models/model_task.py en la lista Literal Status.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>Cuando el status tiene un valor no permitido.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_invalid_tag","title":"<code>test_task_creation_with_invalid_tag()</code>","text":"<p>Comprueba error con un tag inv\u00e1lido.</p> <p>El test verifica que si el valor de tag (etiqueta) es un valor distinto a los valores permitidos, la tarea no ser\u00e1 generada. Los valores admitidos se definen en el m\u00f3dulo models/model_task.py en el Literal Tag.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>Cuando tag tiene un valor no permitido.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_missing_content","title":"<code>test_task_creation_with_missing_content()</code>","text":"<p>Comprueba error generado al no definir content.</p> <p>El test verifica que si una tarea es generada sin hacer la definici\u00f3n correspondiente de la propiedad content, no ser\u00e1 generada.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>Cuando no se define la propiedad content.</p>"},{"location":"referencia_api/tests/models_tests/test_model_task/#tests.models_tests.test_model_task.test_task_creation_with_no_defaults","title":"<code>test_task_creation_with_no_defaults()</code>","text":"<p>Comprueba la creaci\u00f3n de una instancia de Tarea con valores distintos a los defaults.</p> <p>El test verifica que si la tarea se crea con valores distintos a los defaults pero aceptados en sus propiedades status, tag y priority, la tarea se crea correctamente. Los valores aceptados se especifican en models/model_task.py en las listas Literal [Status, Tag, Priority].</p>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/","title":"Pruebas: Repositorio DB","text":""},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#testsrepositories_teststest_repository_db","title":"<code>tests.repositories_tests.test_repository_db</code>","text":"<p>Este m\u00f3dulo contiene las pruebas de integraci\u00f3n para la clase <code>RepositoryDB</code>.</p> <p>Pruebas unitarias para el m\u00f3dlo repositories/repository_db.py.</p>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#tests.repositories_tests.test_repository_db.test_check_or_uncheck_task","title":"<code>test_check_or_uncheck_task(test_repo)</code>","text":"<p>Comprueba que el m\u00e9todo check_or_uncheck_task alterna correctamente el estado de una tarea entre 'pending' y 'completed'.</p> El test usa una tarea apara realizar dos operaciones <ul> <li>de pending -&gt; completed.</li> <li>de completed -&gt; pending.</li> </ul>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#tests.repositories_tests.test_repository_db.test_create_table","title":"<code>test_create_table(test_repo)</code>","text":"<p>Comprueba la correcta creaci\u00f3n de la tabla 'tasks_table'.</p> <p>Este test verifica que el m\u00e9todo create_table() realmente crea la tabla en la base de datos. Se conecta directamente a la base de datos para inspeccionar su esquema y confirmar la existencia de la tabla.</p>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#tests.repositories_tests.test_repository_db.test_delete_task","title":"<code>test_delete_task(test_repo)</code>","text":"<p>Comprueba que el m\u00e9todo delete_task elimina correctamente una tarea de la base de datos.</p>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#tests.repositories_tests.test_repository_db.test_filter_task_by_priority","title":"<code>test_filter_task_by_priority(test_repo)</code>","text":"<p>Verifica el funcionamiento del m\u00e9todo filter_task_priority empleado para filtrar tareas por prioridad.</p> <p>El tests crea 4 nuevas tareas, dos de ellas con la prioridad de interes: (alta) para ser filtradas y comprobar el funcionamiento del m\u00e9todo.</p>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#tests.repositories_tests.test_repository_db.test_filter_task_by_status","title":"<code>test_filter_task_by_status(test_repo)</code>","text":"<p>Verifica el funcionamiento del m\u00e9todo filter_task_status empleado para filtrar tareas por status.</p> <p>El tests crea 4 nuevas tareas, dos de ellas con los status de interes, para ser filtradas y comprobar el funcionamiento del m\u00e9todo.</p>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#tests.repositories_tests.test_repository_db.test_filter_task_by_tag","title":"<code>test_filter_task_by_tag(test_repo)</code>","text":"<p>Verifica el funcionamiento del m\u00e9todo filter_task_tag empleado para filtrar tareas por tag (etiqueta).</p> <p>El tests crea 4 nuevas tareas, dos de ellas con el tag de interes: (proyecto) para ser filtradas y comprobar el funcionamiento del m\u00e9todo.</p>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#tests.repositories_tests.test_repository_db.test_new_task","title":"<code>test_new_task(test_repo)</code>","text":"<p>Verifica el funcionamiento del m\u00e9todo new_task para crear nuevas tareas.</p> <p>Este test verifica que el m\u00e9todo new_task() inserta una fila en 'tasks_table' y que los datos de esa fila (status, tag, content, priority) coinciden exactamente con los datos del objeto Task proporcionado.</p>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#tests.repositories_tests.test_repository_db.test_repo","title":"<code>test_repo()</code>","text":"<p>Pytest fixture para configurar y limpiar la base de datos de prueba.</p> <p>Crea una instancia de RepositoryDB con una base de datos de prueba en memoria y la limpia despu\u00e9s de que el test se completa.</p> <p>Yields:</p> Type Description <code>RepositoryDB</code> <p>Iterator[RepositoryDB]: Una instancia de RepositoryDB conectada a la  base de datos de prueba.</p>"},{"location":"referencia_api/tests/repositories_tests/test_repository_db/#tests.repositories_tests.test_repository_db.test_update_task","title":"<code>test_update_task(test_repo)</code>","text":"<p>Comprueba la correcta actualizaci\u00f3n de los campos de una tarea, incluyendo el campo 'details'.</p> <p>El test crear\u00e1 una tarea inicial 'original_task' para luego ser actualizada con nuevos valores, comprobando el funcionamiento del m\u00e9todo.</p>"}]}